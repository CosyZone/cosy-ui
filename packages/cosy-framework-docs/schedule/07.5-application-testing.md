# æ­¥éª¤ 007.5ï¼šåº”ç”¨ç¨‹åºæµ‹è¯•

## ç›®æ ‡
åˆ›å»ºå®Œæ•´çš„æµ‹è¯•å¥—ä»¶ï¼Œç¡®ä¿åº”ç”¨ç¨‹åºæ ¸å¿ƒåŠŸèƒ½çš„æ­£ç¡®æ€§å’Œå¯é æ€§ã€‚

## ä»»åŠ¡æ¸…å•
- [ ] åˆ›å»ºå•å…ƒæµ‹è¯•
- [ ] åˆ›å»ºé›†æˆæµ‹è¯•
- [ ] åˆ›å»ºæ‰‹åŠ¨æµ‹è¯•è„šæœ¬
- [ ] éªŒè¯æ‰€æœ‰åŠŸèƒ½

## æ‰§è¡Œæ­¥éª¤

### 1. åˆ›å»ºå•å…ƒæµ‹è¯•

**åˆ›å»ºæ–‡ä»¶**: `tests/unit/application.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { Application, Bootstrap } from '../../src/core'
import { HttpContext, HttpMethod, HttpStatus } from '../../src/http'
import { Injectable } from '../../src/container'

describe('Application Core', () => {
  let app: Application

  beforeEach(() => {
    app = new Application()
  })

  afterEach(async () => {
    if (app.isRunning()) {
      await app.stop()
    }
  })

  describe('Application Lifecycle', () => {
    it('should boot application', async () => {
      await app.boot()
      expect(app.isRunning()).toBe(false) // Not started yet
    })

    it('should start and stop application', async () => {
      await app.boot()
      await app.start(3001)
      
      expect(app.isRunning()).toBe(true)
      expect(app.getPort()).toBe(3001)

      await app.stop()
      expect(app.isRunning()).toBe(false)
    })

    it('should not start if already running', async () => {
      await app.boot()
      await app.start(3002)

      await expect(app.start(3003)).rejects.toThrow('Application is already running')
      
      await app.stop()
    })
  })

  describe('Configuration', () => {
    it('should set and get configuration', () => {
      app.config('app.name', 'Test App')
      app.config('database.host', 'localhost')

      expect(app.config('app.name')).toBe('Test App')
      expect(app.config('database.host')).toBe('localhost')
    })

    it('should configure with callback', () => {
      app.configure((app) => {
        app.config('test.value', 'configured')
      })

      expect(app.config('test.value')).toBe('configured')
    })
  })

  describe('Service Container Integration', () => {
    it('should bind and resolve services', () => {
      @Injectable
      class TestService {
        getValue() {
          return 'test-value'
        }
      }

      app.bind('test-service', TestService)
      const service = app.resolve<TestService>('test-service')

      expect(service).toBeInstanceOf(TestService)
      expect(service.getValue()).toBe('test-value')
    })

    it('should register singleton services', () => {
      class SingletonService {
        private static count = 0
        public readonly id: number

        constructor() {
          this.id = ++SingletonService.count
        }
      }

      app.singleton('singleton', SingletonService)

      const instance1 = app.resolve<SingletonService>('singleton')
      const instance2 = app.resolve<SingletonService>('singleton')

      expect(instance1).toBe(instance2)
      expect(instance1.id).toBe(1)
    })
  })

  describe('Routing Integration', () => {
    it('should register and handle routes', async () => {
      app.get('/test', () => 'Hello World')
      app.post('/users', () => ({ id: 1, name: 'John' }))

      const getRequest = HttpContext.create({ method: 'GET', url: '/test' }).request
      const postRequest = HttpContext.create({ method: 'POST', url: '/users' }).request

      const getResponse = await app.handle(getRequest)
      const postResponse = await app.handle(postRequest)

      expect(getResponse.getStatus()).toBe(HttpStatus.OK)
      expect(getResponse.getContent()).toBe('Hello World')

      expect(postResponse.getStatus()).toBe(HttpStatus.OK)
      expect(JSON.parse(postResponse.getContent())).toEqual({ id: 1, name: 'John' })
    })

    it('should handle route parameters', async () => {
      app.get('/users/{id}', (context) => {
        return { userId: context.request.params.id }
      })

      const request = HttpContext.create({ method: 'GET', url: '/users/123' }).request
      const response = await app.handle(request)

      expect(response.getStatus()).toBe(HttpStatus.OK)
      expect(JSON.parse(response.getContent())).toEqual({ userId: '123' })
    })

    it('should return 404 for unknown routes', async () => {
      const request = HttpContext.create({ method: 'GET', url: '/unknown' }).request
      const response = await app.handle(request)

      expect(response.getStatus()).toBe(HttpStatus.NOT_FOUND)
      expect(JSON.parse(response.getContent())).toMatchObject({
        error: 'Route not found',
        path: '/unknown',
        method: 'GET'
      })
    })

    it('should support route groups', async () => {
      app.group('/api', (router) => {
        router.get('/status', () => ({ status: 'ok' }))
        router.get('/health', () => ({ health: 'good' }))
      })

      const statusRequest = HttpContext.create({ method: 'GET', url: '/api/status' }).request
      const healthRequest = HttpContext.create({ method: 'GET', url: '/api/health' }).request

      const statusResponse = await app.handle(statusRequest)
      const healthResponse = await app.handle(healthRequest)

      expect(statusResponse.getStatus()).toBe(HttpStatus.OK)
      expect(healthResponse.getStatus()).toBe(HttpStatus.OK)
    })
  })

  describe('Middleware Integration', () => {
    it('should execute global middleware', async () => {
      const order: number[] = []

      app.use(async (context, next) => {
        order.push(1)
        await next()
        order.push(4)
      })

      app.use(async (context, next) => {
        order.push(2)
        await next()
        order.push(3)
      })

      app.get('/test', () => {
        order.push(5)
        return 'success'
      })

      const request = HttpContext.create({ method: 'GET', url: '/test' }).request
      await app.handle(request)

      expect(order).toEqual([1, 2, 5, 3, 4])
    })

    it('should handle middleware errors', async () => {
      app.use(async () => {
        throw new Error('Middleware error')
      })

      app.get('/test', () => 'success')

      const request = HttpContext.create({ method: 'GET', url: '/test' }).request
      const response = await app.handle(request)

      expect(response.getStatus()).toBe(HttpStatus.INTERNAL_SERVER_ERROR)
      expect(JSON.parse(response.getContent())).toMatchObject({
        error: 'Middleware error'
      })
    })
  })

  describe('Application Factory', () => {
    it('should create application with static method', () => {
      const staticApp = Application.create({
        name: 'Static App',
        port: 4000
      })

      expect(staticApp.config('app.name')).toBe('Static App')
      expect(staticApp.config('app.port')).toBe(4000)
    })
  })

  describe('Bootstrap', () => {
    it('should bootstrap application', async () => {
      const bootstrap = Bootstrap.create({
        config: {
          name: 'Bootstrap App',
          port: 5000
        }
      })

      const bootstrappedApp = await bootstrap.start()
      
      expect(bootstrappedApp.isRunning()).toBe(true)
      expect(bootstrappedApp.config('app.name')).toBe('Bootstrap App')
      
      await bootstrappedApp.stop()
    })
  })
})
```

### 2. åˆ›å»ºæ‰‹åŠ¨æµ‹è¯•è„šæœ¬

**åˆ›å»ºæ–‡ä»¶**: `tests/manual-application-test.ts`

```typescript
import { 
  Application, 
  Bootstrap,
  createWebApp,
  gracefulShutdown,
  App,
  Controller,
  Get,
  Post
} from '../src/core'
import { Injectable, Inject } from '../src/container'
import { cors, logger } from '../src/middleware'
import { Environment } from '../src/config'

console.log('=== åº”ç”¨ç¨‹åºæ ¸å¿ƒæµ‹è¯• ===')

// 1. åŸºç¡€åº”ç”¨åˆ›å»ºå’Œé…ç½®
console.log('\n1. åŸºç¡€åº”ç”¨åˆ›å»º')

const app = Application.create({
  name: 'Cosy Framework Test App',
  debug: true,
  port: 3000
})

console.log('åº”ç”¨åç§°:', app.config('app.name'))
console.log('è°ƒè¯•æ¨¡å¼:', app.config('app.debug'))
console.log('ç«¯å£:', app.config('app.port'))

// 2. æœåŠ¡æ³¨å†Œæµ‹è¯•
console.log('\n2. æœåŠ¡æ³¨å†Œæµ‹è¯•')

@Injectable
class DatabaseService {
  connect() {
    return 'Database connected'
  }
}

@Injectable
class UserService {
  constructor(@Inject('DatabaseService') private db: DatabaseService) {}

  getUsers() {
    return [
      { id: 1, name: 'John Doe' },
      { id: 2, name: 'Jane Smith' }
    ]
  }

  getDatabaseStatus() {
    return this.db.connect()
  }
}

app.bind('DatabaseService', DatabaseService)
app.bind('UserService', UserService)

const userService = app.resolve<UserService>('UserService')
console.log('ç”¨æˆ·æœåŠ¡æµ‹è¯•:', userService.getDatabaseStatus())
console.log('ç”¨æˆ·åˆ—è¡¨:', userService.getUsers())

// 3. ä¸­é—´ä»¶æµ‹è¯•
console.log('\n3. ä¸­é—´ä»¶æµ‹è¯•')

app.use(logger())
app.use(cors({ origin: '*' }))

app.use(async (context, next) => {
  console.log(`è¯·æ±‚: ${context.request.method} ${context.request.path}`)
  const start = Date.now()
  await next()
  const duration = Date.now() - start
  console.log(`å“åº”æ—¶é—´: ${duration}ms`)
})

// 4. è·¯ç”±æµ‹è¯•
console.log('\n4. è·¯ç”±æ³¨å†Œ')

app.get('/', () => {
  return {
    message: 'Welcome to Cosy Framework!',
    version: '0.1.0',
    timestamp: new Date().toISOString()
  }
})

app.get('/users', (context) => {
  const userService = app.resolve<UserService>('UserService')
  return {
    users: userService.getUsers(),
    total: 2
  }
})

app.get('/users/{id}', (context) => {
  const id = parseInt(context.request.params.id)
  const users = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
  ]
  
  const user = users.find(u => u.id === id)
  if (!user) {
    context.response.status(404)
    return { error: 'User not found' }
  }
  
  return { user }
})

app.post('/users', (context) => {
  const { name, email } = context.request.body
  return {
    id: 3,
    name,
    email,
    created_at: new Date().toISOString()
  }
})

// API è·¯ç”±ç»„
app.group('/api/v1', (router) => {
  router.get('/status', () => ({
    status: 'ok',
    timestamp: Date.now(),
    environment: Environment.getCurrent()
  }))

  router.get('/health', () => ({
    health: 'good',
    uptime: process.uptime(),
    memory: process.memoryUsage()
  }))
})

console.log('æ³¨å†Œçš„è·¯ç”±æ•°é‡:', app.getRouter().getRoutes().length)

// 5. æ§åˆ¶å™¨è£…é¥°å™¨æµ‹è¯•ï¼ˆæ¼”ç¤ºï¼‰
console.log('\n5. æ§åˆ¶å™¨è£…é¥°å™¨æ¼”ç¤º')

@Controller('/api/posts')
class PostController {
  @Get('/')
  index() {
    return {
      posts: [
        { id: 1, title: 'First Post' },
        { id: 2, title: 'Second Post' }
      ]
    }
  }

  @Get('/{id}')
  show() {
    return { post: { id: 1, title: 'Post Detail' } }
  }

  @Post('/')
  create() {
    return { message: 'Post created', id: 3 }
  }
}

console.log('æ§åˆ¶å™¨è£…é¥°å™¨å·²å®šä¹‰ï¼ˆéœ€è¦æ‰‹åŠ¨æ³¨å†Œåˆ°è·¯ç”±ï¼‰')

// 6. åº”ç”¨å¯åŠ¨æµ‹è¯•
console.log('\n6. åº”ç”¨å¯åŠ¨æµ‹è¯•')

async function testApplication() {
  try {
    console.log('æ­£åœ¨å¯åŠ¨åº”ç”¨...')
    await app.boot()
    await app.start(3000)

    console.log('âœ“ åº”ç”¨å¯åŠ¨æˆåŠŸ')
    console.log('åº”ç”¨çŠ¶æ€:', app.isRunning() ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢')
    console.log('ç›‘å¬ç«¯å£:', app.getPort())

    // æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†æµ‹è¯•
    console.log('\n7. è¯·æ±‚å¤„ç†æµ‹è¯•')
    
    const { HttpContext } = await import('../src/http')
    
    const testRequests = [
      { method: 'GET', url: '/' },
      { method: 'GET', url: '/users' },
      { method: 'GET', url: '/users/1' },
      { method: 'GET', url: '/api/v1/status' },
      { method: 'GET', url: '/nonexistent' }
    ]

    for (const req of testRequests) {
      const context = HttpContext.create(req)
      const response = await app.handle(context.request)
      
      console.log(`${req.method} ${req.url} â†’ ${response.getStatus()}`)
      if (response.getContent()) {
        const content = response.getContent()
        if (content.length < 200) {
          console.log(`  å“åº”: ${content}`)
        } else {
          console.log(`  å“åº”: ${content.substring(0, 100)}...`)
        }
      }
    }

    // åœæ­¢åº”ç”¨
    console.log('\næ­£åœ¨åœæ­¢åº”ç”¨...')
    await app.stop()
    console.log('âœ“ åº”ç”¨å·²åœæ­¢')

  } catch (error) {
    console.error('åº”ç”¨æµ‹è¯•å¤±è´¥:', error)
  }
}

// 8. Bootstrap æµ‹è¯•
console.log('\n8. Bootstrap æµ‹è¯•')

async function testBootstrap() {
  try {
    console.log('ä½¿ç”¨ Bootstrap å¯åŠ¨åº”ç”¨...')
    
    const bootstrap = Bootstrap.create({
      config: {
        name: 'Bootstrap Test App',
        port: 3001,
        debug: true
      },
      hooks: {
        beforeStart: () => console.log('ğŸ”„ å‡†å¤‡å¯åŠ¨...'),
        afterStart: () => console.log('âœ… å¯åŠ¨å®Œæˆ!'),
        beforeStop: () => console.log('ğŸ”„ å‡†å¤‡åœæ­¢...'),
        afterStop: () => console.log('âœ… åœæ­¢å®Œæˆ!')
      }
    })

    const bootstrappedApp = await bootstrap.start()
    console.log('Bootstrap åº”ç”¨è¿è¡ŒçŠ¶æ€:', bootstrappedApp.isRunning())
    
    // ç¨ç­‰ä¸€ä¸‹ç„¶ååœæ­¢
    setTimeout(async () => {
      await bootstrappedApp.stop()
    }, 1000)

  } catch (error) {
    console.error('Bootstrap æµ‹è¯•å¤±è´¥:', error)
  }
}

// è¿è¡Œæµ‹è¯•
testApplication().then(() => {
  return testBootstrap()
}).then(() => {
  console.log('\n=== åº”ç”¨ç¨‹åºæ ¸å¿ƒæµ‹è¯•å®Œæˆ ===')
}).catch(error => {
  console.error('æµ‹è¯•è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error)
})
```

### 3. è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œå•å…ƒæµ‹è¯•
npm test tests/unit/application.test.ts

# è¿è¡Œæ‰‹åŠ¨æµ‹è¯•
npx tsx tests/manual-application-test.ts
```

## æµ‹è¯•è¦†ç›–èŒƒå›´

1. **ç”Ÿå‘½å‘¨æœŸæµ‹è¯•**
   - å¯åŠ¨å’Œåœæ­¢
   - ç”Ÿå‘½å‘¨æœŸé’©å­
   - é”™è¯¯å¤„ç†

2. **é…ç½®æµ‹è¯•**
   - é…ç½®è¯»å†™
   - ç¯å¢ƒé…ç½®
   - é…ç½®åˆå¹¶

3. **æœåŠ¡å®¹å™¨æµ‹è¯•**
   - æœåŠ¡ç»‘å®šå’Œè§£æ
   - å•ä¾‹æœåŠ¡
   - ä¾èµ–æ³¨å…¥

4. **è·¯ç”±æµ‹è¯•**
   - è·¯ç”±æ³¨å†Œ
   - è·¯ç”±å‚æ•°
   - è·¯ç”±ç»„
   - 404 å¤„ç†

5. **ä¸­é—´ä»¶æµ‹è¯•**
   - ä¸­é—´ä»¶æ‰§è¡Œé¡ºåº
   - é”™è¯¯å¤„ç†
   - å…¨å±€ä¸­é—´ä»¶

6. **Bootstrap æµ‹è¯•**
   - é…ç½®åŠ è½½
   - æœåŠ¡æä¾›è€…
   - ç”Ÿå‘½å‘¨æœŸé’©å­

## å®Œæˆæ ‡å¿—
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] æ‰‹åŠ¨æµ‹è¯•è„šæœ¬è¿è¡ŒæˆåŠŸ
- [ ] æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°ç›®æ ‡
- [ ] æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½éƒ½æœ‰æµ‹è¯•
- [ ] é”™è¯¯å¤„ç†æµ‹è¯•å®Œæ•´
- [ ] TypeScript ç±»å‹æ£€æŸ¥æ— é”™è¯¯

## ä¸‹ä¸€æ­¥
å®Œæˆæ­¤æ­¥éª¤åï¼Œç»§ç»­æ‰§è¡Œ `step-008-basic-example.md`ã€‚ 
