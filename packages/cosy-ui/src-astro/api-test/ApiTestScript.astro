---



/**
 * @component ApiTestScript
 *
 * @description
 * ApiTestScript ç»„ä»¶æä¾›APIæµ‹è¯•çš„æ ¸å¿ƒJavaScripté€»è¾‘ï¼ŒåŒ…æ‹¬è¯·æ±‚å‘é€ã€å“åº”å¤„ç†å’Œç»“æœå±•ç¤ºã€‚
 * æ”¯æŒå¤šç§HTTPæ–¹æ³•ã€å‚æ•°éªŒè¯ã€è¯·æ±‚å¤´é…ç½®å’Œè¯¦ç»†çš„å“åº”ä¿¡æ¯å±•ç¤ºã€‚
 *
 * @design
 * è®¾è®¡ç†å¿µï¼š
 * 1. å¥å£®æ€§ - å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µå¤„ç†
 * 2. å¯è§‚æµ‹æ€§ - è¯¦ç»†çš„æ—¥å¿—è®°å½•å’ŒçŠ¶æ€åé¦ˆ
 * 3. çµæ´»æ€§ - æ”¯æŒå¤šç§è¯·æ±‚é…ç½®å’Œè‡ªå®šä¹‰é€‰é¡¹
 * 4. ç”¨æˆ·ä½“éªŒ - æ¸…æ™°çš„åŠ è½½çŠ¶æ€å’Œç»“æœå±•ç¤º
 *
 * @usage
 * åŸºæœ¬ç”¨æ³•ï¼š
 * ```astro
 * <ApiTestScript />
 * ```
 *
 * å¸¦é…ç½®çš„ç”¨æ³•ï¼š
 * ```astro
 * <ApiTestScript
 *   showResponseTime={true}
 *   showRequestDetails={true}
 *   defaultHeaders={{ 'Authorization': 'Bearer token' }}
 * />
 * ```
 *
 * @props
 * @prop {boolean} [showResponseTime=true] - æ˜¯å¦æ˜¾ç¤ºå“åº”æ—¶é—´
 * @prop {boolean} [showRequestDetails=false] - æ˜¯å¦æ˜¾ç¤ºè¯·æ±‚è¯¦æƒ…
 * @prop {Record<string, string>} [defaultHeaders] - é»˜è®¤è¯·æ±‚å¤´
 */

import { cn } from '../../src/class';

interface Props {
    showResponseTime?: boolean;
    showRequestDetails?: boolean;
    defaultHeaders?: Record<string, string>;
}

const {
    showResponseTime = true,
    showRequestDetails = false,
    defaultHeaders = {},
} = Astro.props;

// ä½¿ç”¨ class builder æ„å»ºç±»å
const resultContainerClass = cn().add('space-y-3').build();

const statusRowClass = cn().flex().items('center').gap(2).build();

const statusLabelClass = cn()
    .add('cosy:font-semibold', 'cosy:text-base-content')
    .build();

const statusSubtextClass = cn()
    .add('cosy:text-sm', 'cosy:text-base-content/70')
    .build();

const responseTimeLabelClass = cn()
    .add('cosy:font-semibold', 'cosy:text-base-content')
    .build();

const responseTimeValueClass = cn().add('cosy:text-success').build();

const urlLabelClass = cn()
    .add('cosy:font-semibold', 'cosy:text-base-content')
    .build();

const urlCodeClass = cn()
    .add(
        'cosy:text-primary',
        'cosy:font-mono',
        'cosy:text-sm',
        'cosy:break-all',
    )
    .build();

const contentLabelClass = cn()
    .add('cosy:font-semibold', 'cosy:text-base-content')
    .build();

const codeBlockClass = cn()
    .add('cosy:mt-2')
    .add('cosy:p-3')
    .add('cosy:bg-base-300', 'cosy:rounded-lg')
    .add('cosy:overflow-x-auto', 'cosy:text-sm')
    .build();

const errorContainerClass = cn().add('cosy:text-error').build();

const errorLabelClass = cn().add('cosy:font-semibold').build();

const errorListClass = cn()
    .add('cosy:mt-2', 'cosy:list-disc', 'cosy:list-inside')
    .build();

const loadingClass = cn()
    .add('loading', 'loading-spinner', 'loading-sm')
    .build();

const loadingTextClass = cn().add('cosy:text-primary', 'cosy:italic').build();
---

<script
    is:inline
    define:vars={{
        showResponseTime,
        showRequestDetails,
        defaultHeaders,
        resultContainerClass,
        statusRowClass,
        statusLabelClass,
        statusSubtextClass,
        responseTimeLabelClass,
        responseTimeValueClass,
        urlLabelClass,
        urlCodeClass,
        contentLabelClass,
        codeBlockClass,
        errorContainerClass,
        errorLabelClass,
        errorListClass,
        loadingClass,
        loadingTextClass,
    }}
>
    // @ts-nocheck - å˜é‡é€šè¿‡ Astro çš„ define:vars åœ¨è¿è¡Œæ—¶æ³¨å…¥
    // æ ¼å¼åŒ–å“åº”æ˜¾ç¤º
    function formatResponse(response, data, responseTime) {
        const statusColor = response.ok ? 'success' : 'error';
        const statusText = response.ok ? 'æˆåŠŸ' : 'å¤±è´¥';
        const badgeClass = `badge badge-${statusColor}`;

        let result = `
      <div class="${resultContainerClass}">
        <div class="${statusRowClass}">
          <span class="${statusLabelClass}">HTTPçŠ¶æ€:</span> 
          <span class="${badgeClass}">${response.status} ${response.statusText}</span>
          <span class="${statusSubtextClass}">(${statusText})</span>
        </div>
    `;

        if (showResponseTime && responseTime) {
            result += `
        <div>
          <span class="${responseTimeLabelClass}">å“åº”æ—¶é—´:</span> 
          <span class="${responseTimeValueClass}">${responseTime}ms</span>
        </div>
      `;
        }

        if (showRequestDetails) {
            result += `
        <div>
          <span class="${urlLabelClass}">è¯·æ±‚URL:</span> 
          <code class="${urlCodeClass}">${response.url}</code>
        </div>
      `;
        }

        result += `
        <div>
          <span class="${contentLabelClass}">å“åº”å†…å®¹:</span>
          <pre class="${codeBlockClass}">${JSON.stringify(data, null, 2)}</pre>
        </div>
      </div>
    `;

        return result;
    }

    // æ”¶é›†è¯·æ±‚å¤´
    function collectHeaders() {
        const headers = { ...defaultHeaders };

        // æ”¶é›†è‡ªå®šä¹‰è¯·æ±‚å¤´
        document
            .querySelectorAll('[data-header-key][data-header-value]')
            .forEach((input) => {
                const key = input.dataset.headerKey;
                const value = input.dataset.headerValue;
                if (key && value) {
                    headers[key] = value;
                }
            });

        // è®¾ç½®é»˜è®¤Content-Type
        if (!headers['Content-Type']) {
            headers['Content-Type'] = 'application/json';
        }

        return headers;
    }

    // éªŒè¯å‚æ•°
    function validateParams(params) {
        const errors = [];

        Object.entries(params).forEach(([key, value]) => {
            const input = document.querySelector(
                `[data-param="${key}"][data-endpoint]`,
            );
            if (input) {
                const validation = JSON.parse(input.dataset.validation || '{}');
                const required = input.dataset.required === 'true';

                if (required && (!value || value.toString().trim() === '')) {
                    errors.push(`${key} æ˜¯å¿…å¡«å‚æ•°`);
                }

                if (validation.min && Number(value) < validation.min) {
                    errors.push(`${key} ä¸èƒ½å°äº ${validation.min}`);
                }

                if (validation.max && Number(value) > validation.max) {
                    errors.push(`${key} ä¸èƒ½å¤§äº ${validation.max}`);
                }

                if (
                    validation.pattern &&
                    !new RegExp(validation.pattern).test(value)
                ) {
                    errors.push(`${key} æ ¼å¼ä¸æ­£ç¡®`);
                }
            }
        });

        return { isValid: errors.length === 0, errors };
    }

    // æµ‹è¯•APIç«¯ç‚¹
    async function testEndpoint(endpoint, method) {
        console.log('ğŸš€ å¼€å§‹æµ‹è¯•ç«¯ç‚¹:', endpoint, method);

        // æ‰¾åˆ°æ‰€æœ‰åŒ¹é…çš„ç»“æœåŒºåŸŸå’ŒæŒ‰é’®
        const resultDivs = document.querySelectorAll(
            `[data-result="${endpoint}"]`,
        );
        const testBtns = document.querySelectorAll(
            `[data-endpoint="${endpoint}"][data-method="${method}"]`,
        );

        console.log('æ‰¾åˆ°ç»“æœåŒºåŸŸæ•°é‡:', resultDivs.length);
        console.log('æ‰¾åˆ°æŒ‰é’®æ•°é‡:', testBtns.length);

        // ä½¿ç”¨ç¬¬ä¸€ä¸ªåŒ¹é…çš„å…ƒç´ 
        const resultDiv = resultDivs[0];
        const testBtn = testBtns[0];

        if (!resultDiv || !testBtn) {
            console.error('âŒ æ‰¾ä¸åˆ°ç»“æœåŒºåŸŸæˆ–æŒ‰é’®:', { endpoint, method });
            return;
        }

        // æ˜¾ç¤ºç»“æœåŒºåŸŸ
        resultDiv.classList.remove('hidden');
        resultDiv.innerHTML = `<span class="${loadingTextClass}">æ­£åœ¨æµ‹è¯•æ¥å£...</span>`;

        // ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        testBtn.disabled = true;
        testBtn.innerHTML = `<span class="${loadingClass}"></span> æµ‹è¯•ä¸­...`;

        const startTime = Date.now();

        try {
            // æ„å»ºURLå’Œå‚æ•°
            let url = endpoint;
            const params = {};

            // æ”¶é›†å‚æ•°å€¼
            document
                .querySelectorAll(`[data-endpoint="${endpoint}"][data-param]`)
                .forEach((input) => {
                    const paramName = input.dataset.param;
                    if (paramName) {
                        if (input.type === 'checkbox') {
                            params[paramName] = input.checked;
                        } else if (input.type === 'radio') {
                            if (input.checked) {
                                params[paramName] = input.value;
                            }
                        } else if (input.value.trim()) {
                            params[paramName] = input.value.trim();
                        }
                    }
                });

            // éªŒè¯å‚æ•°
            const validation = validateParams(params);
            if (!validation.isValid) {
                resultDiv.innerHTML = `
          <div class="${errorContainerClass}">
            <span class="${errorLabelClass}">å‚æ•°éªŒè¯å¤±è´¥:</span>
            <ul class="${errorListClass}">
              ${validation.errors.map((error) => `<li>${error}</li>`).join('')}
            </ul>
          </div>
        `;
                return;
            }

            // ä¸ºGETè¯·æ±‚æ·»åŠ æŸ¥è¯¢å‚æ•°
            if (method === 'GET' && Object.keys(params).length > 0) {
                const searchParams = new URLSearchParams();
                Object.entries(params).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && value !== '') {
                        searchParams.append(key, value.toString());
                    }
                });
                url += `?${searchParams.toString()}`;
            }

            // æ”¶é›†è¯·æ±‚å¤´
            const headers = collectHeaders();

            console.log('ğŸ“¤ å‘é€è¯·æ±‚:', { url, method, params, headers });

            // å‘é€è¯·æ±‚
            const response = await fetch(url, {
                method: method,
                headers,
                body: method !== 'GET' ? JSON.stringify(params) : undefined,
            });

            const responseTime = Date.now() - startTime;

            // å¤„ç†å“åº”
            let responseText = '';
            try {
                responseText = await response.text();
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch {
                    data = responseText;
                }

                resultDiv.innerHTML = formatResponse(
                    response,
                    data,
                    responseTime,
                );
                console.log('âœ… è¯·æ±‚æˆåŠŸ:', { response, data, responseTime });
            } catch (error) {
                resultDiv.innerHTML = formatResponse(
                    response,
                    '[æ— æ³•è¯»å–å“åº”å†…å®¹]',
                    responseTime,
                );
                console.error('âŒ å“åº”è§£æå¤±è´¥:', error);
            }
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : 'Unknown error';
            resultDiv.innerHTML = `
        <div class="${errorContainerClass}">
          <span class="${errorLabelClass}">è¯·æ±‚å¤±è´¥:</span> ${errorMessage}
        </div>
      `;
            console.error('âŒ è¯·æ±‚å¤±è´¥:', error);
        } finally {
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            testBtn.disabled = false;
            testBtn.innerHTML = 'æµ‹è¯•æ¥å£';
        }
    }

    // å¿«é€Ÿå¡«å……å‚æ•°
    function quickFill(endpoint, values) {
        console.log('âš¡ å¿«é€Ÿå¡«å……å‚æ•°:', { endpoint, values });

        Object.entries(values).forEach(([key, value]) => {
            const inputs = document.querySelectorAll(
                `[data-endpoint="${endpoint}"][data-param="${key}"]`,
            );
            console.log(`æ‰¾åˆ°å‚æ•° ${key} çš„è¾“å…¥æ¡†æ•°é‡:`, inputs.length);

            // ä½¿ç”¨ç¬¬ä¸€ä¸ªåŒ¹é…çš„è¾“å…¥æ¡†
            const input = inputs[0];
            if (input) {
                if (input.type === 'checkbox') {
                    input.checked = Boolean(value);
                } else if (input.type === 'radio') {
                    const radioInput = document.querySelector(
                        `[data-endpoint="${endpoint}"][data-param="${key}"][value="${value}"]`,
                    );
                    if (radioInput) {
                        radioInput.checked = true;
                    }
                } else {
                    input.value = value.toString();
                }
                console.log(`âœ… å·²å¡«å……å‚æ•° ${key}:`, value);
            } else {
                console.warn(`âš ï¸ æœªæ‰¾åˆ°å‚æ•° ${key} çš„è¾“å…¥æ¡†`);
            }
        });
    }

    // é¡µé¢åŠ è½½å®Œæˆåç»‘å®šäº‹ä»¶
    document.addEventListener('DOMContentLoaded', () => {
        console.log('ğŸš€ APIæµ‹è¯•ç»„ä»¶å·²åŠ è½½ï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•äº†ï¼');

        // ç»‘å®šæµ‹è¯•æŒ‰é’®äº‹ä»¶
        document
            .querySelectorAll('[data-endpoint][data-method]')
            .forEach((btn) => {
                btn.addEventListener('click', (event) => {
                    const clickedBtn = event.currentTarget;
                    const endpoint = clickedBtn.dataset.endpoint;
                    const method = clickedBtn.dataset.method;
                    console.log('ğŸ–±ï¸ ç‚¹å‡»äº†æŒ‰é’®:', { endpoint, method });
                    if (endpoint && method) {
                        testEndpoint(endpoint, method);
                    }
                });
            });

        // ç»‘å®šå¿«é€Ÿæµ‹è¯•æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('[data-quick-test]').forEach((btn) => {
            btn.addEventListener('click', (event) => {
                const clickedBtn = event.currentTarget;
                const endpoint = clickedBtn.dataset.endpoint;
                const values = JSON.parse(clickedBtn.dataset.quickTest || '{}');
                console.log('âš¡ å¿«é€Ÿå¡«å……:', { endpoint, values });
                if (endpoint && values) {
                    quickFill(endpoint, values);
                }
            });
        });

        // ç»‘å®šè¯·æ±‚å¤´è¾“å…¥æ¡†äº‹ä»¶
        document.querySelectorAll('[data-header-key]').forEach((input) => {
            input.addEventListener('input', (event) => {
                const target = event.target;
                const key = target.dataset.headerKey;
                const value = target.value;
                if (key) {
                    target.dataset.headerValue = value;
                }
            });
        });
    });
</script>
