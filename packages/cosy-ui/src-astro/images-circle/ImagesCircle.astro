---
/**
 * @component ImagesCircle
 * @description 3D透视图片展示组件，模拟图片从远处走向观者的效果，中间图片最近最大，两侧图片渐远渐小
 * @usage
 * ```astro
 * <ImagesCircle
 *   images={[
 *     'image1.jpg',
 *     'image2.jpg',
 *     'image3.jpg',
 *     'image4.jpg'
 *   ]}
 *   size="md"
 * />
 * ```
 * @props
 * @prop {BackgroundColor} [background] - 背景颜色
 * @prop {string} [class] - 自定义 CSS 类名
 * @prop {ImageSource[]} images - 图片源数组，可以是字符串URL或ImageMetadata对象，第一张为中心主图，其余环绕显示
 * @prop {string} [rounded='lg'] - 图片圆角，可选值：none、sm、md、lg、xl、2xl、3xl、full
 * @prop {string} [shadow='lg'] - 图片阴影，可选值：none、sm、md、lg、xl
 * @prop {string} [size='md'] - 组件大小，可选值：sm、md、lg、xl
 * @prop {string} [spacing='md'] - 圆圈大小（图片间距），可选值：sm、md、lg、xl
 */
;
import type { IImagesCircleProps } from "./types";
import { Container } from "../container";
import ImagesCircleErrorView from "./ImagesCircleErrorView.astro";

const {
	images,
	class: className = "",
	size = "md",
	shadow = "lg",
	rounded = "lg",
	spacing = "md",
	background,
} = Astro.props as IImagesCircleProps;

// 验证图片数组
const imageCount = images?.length || 0;
const isValidImages =
	images &&
	Array.isArray(images) &&
	images.length >= 2 &&
	images.length % 2 === 1;

// 尺寸映射 - 3D透视的比例
const sizeMap = {
	sm: { center: 120, satellite: 60, container: 200 },
	md: { center: 180, satellite: 90, container: 400 },
	lg: { center: 240, satellite: 120, container: 600 },
	xl: { center: 300, satellite: 150, container: 800 },
};

// 间距映射（图片左右展开的范围）
const spacingMap = {
	sm: 180,
	md: 250,
	lg: 320,
	xl: 400,
};

// 阴影映射
const shadowMap = {
	none: "",
	sm: "cosy:shadow-sm",
	md: "cosy:shadow-md",
	lg: "cosy:shadow-lg",
	xl: "cosy:shadow-xl",
};

// 圆角映射
const roundedMap = {
	none: "cosy:rounded-none",
	sm: "cosy:rounded-sm",
	md: "cosy:rounded-md",
	lg: "cosy:rounded-lg",
	xl: "cosy:rounded-xl",
	"2xl": "cosy:rounded-2xl",
	"3xl": "cosy:rounded-3xl",
	full: "cosy:rounded-full",
};

const currentSize = sizeMap[size];
const radius = spacingMap[spacing];
const shadowClass = shadowMap[shadow];
const roundedClass = roundedMap[rounded];

// 计算3D透视位置 - 模拟图片从远处走向观者的效果
const get3DPositions = (count: number) => {
	if (count <= 1) return [];

	const positions = [];
	const totalImages = count;

	// 创建一个弧形排列，模拟3D空间中的深度
	for (let i = 0; i < totalImages; i++) {
		// 计算在弧形中的位置 (-1 到 1)
		const normalizedPosition =
			totalImages === 1 ? 0 : (i / (totalImages - 1)) * 2 - 1;

		// 计算3D透视效果
		const distance = Math.abs(normalizedPosition); // 距离中心的距离 (0-1)
		const depthFactor = 1 - distance * 0.7; // 深度因子，中心为1，边缘为0.3

		// 计算位置
		const x = normalizedPosition * radius * (1 - distance * 0.1); // X轴位置，增加展开范围
		const y = distance * distance * 20; // Y轴轻微下沉，减少下沉幅度
		const z = -distance * 80; // Z轴深度，稍微减少深度差

		// 计算缩放（近大远小）
		const scale = 0.7 + depthFactor * 0.5; // 0.7 到 1.2 之间，增大整体尺寸

		// 计算旋转（模拟3D旋转）
		const rotateY = normalizedPosition * 20; // Y轴旋转，稍微减少旋转角度
		const rotateX = distance * 8; // X轴轻微旋转，减少倾斜

		// 计算透明度（远处稍微透明）
		const opacity = 0.75 + depthFactor * 0.25; // 0.75 到 1.0 之间，提高边缘图片可见度

		// 计算模糊（远处稍微模糊）
		const blur = distance * 0.5; // 0 到 0.5px 模糊，减少模糊程度

		positions.push({
			x,
			y,
			z,
			scale,
			rotateX,
			rotateY,
			opacity,
			blur,
			zIndex: Math.floor(depthFactor * 10), // 根据深度设置层级
			isCenter: i === Math.floor(totalImages / 2), // 标记中心图片
		});
	}

	return positions;
};

const positions3D = get3DPositions(imageCount);
---

{isValidImages ? (
  <Container
    aria-label="image-circle-container"
    width="full"
    class={`${className}`}
    background={background}
    padding="none"
    contentCentered
    style={`width: ${currentSize.container}px; height: ${currentSize.container}px; perspective: 1000px;`}
  >
    <div 
      style={`width: ${currentSize.container}px; height: ${currentSize.container}px; transform-style: preserve-3d;`}
    >
      <!-- 所有图片按3D位置排列 -->
      {images.map((imageSrc, index) => {
        const position = positions3D[index];
        if (!position) return null;
        
        const imageSize = currentSize.center * position.scale;
        
        return (
          <div
            class={`image-3d ${position.isCenter ? 'center-image' : 'side-image'}`}
            style={`
              width: ${imageSize}px;
              height: ${imageSize}px;
              left: 50%;
              top: 50%;
              transform: translate(-50%, -50%) 
                         translate3d(${position.x}px, ${position.y}px, ${position.z}px) 
                         rotateX(${position.rotateX}deg) 
                         rotateY(${position.rotateY}deg);
              opacity: ${position.opacity};
              z-index: ${position.zIndex};
              filter: blur(${position.blur}px);
            `}
          >
            <img
              src={typeof imageSrc === 'string' ? imageSrc : imageSrc.src}
              alt={`图片 ${index + 1}`}
              width={imageSize}
              height={imageSize}
              loading="lazy"
              class={`img-3d ${shadowClass} ${roundedClass}`}
              style={`width: ${imageSize}px; height: ${imageSize}px;`}
            />
          </div>
        );
      })}
    </div>
  </Container>
) : (
  <ImagesCircleErrorView
    imageCount={imageCount}
    class={className}
  />
)}

<style>
  .image-3d {
    position: absolute;
    transform-style: preserve-3d;
    transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .img-3d {
    object-fit: cover;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    backface-visibility: hidden;
  }

  /* 中心图片特殊样式 */
  .center-image {
    z-index: 100;
  }

  .center-image .img-3d {
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
  }

  /* 侧边图片样式 */
  .side-image .img-3d {
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  /* 悬停效果 - 轻微的前进效果 */
  .image-3d:hover {
    transform: translate(-50%, -50%) 
               translate3d(var(--x, 0), var(--y, 0), calc(var(--z, 0) + 20px)) 
               rotateX(var(--rx, 0)) 
               rotateY(var(--ry, 0)) 
               scale(1.05);
  }

  .img-3d:hover {
    filter: brightness(1.1) contrast(1.1);
  }

  /* 标题样式 */
  .image-caption {
    position: absolute;
    bottom: -35px;
    left: 50%;
    transform: translateX(-50%);
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  .image-caption p {
    font-size: 11px;
    color: #333;
    background: rgba(255, 255, 255, 0.95);
    padding: 6px 10px;
    border-radius: 6px;
    margin: 0;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(0, 0, 0, 0.08);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .image-3d:hover .image-caption {
    opacity: 1;
  }

  /* 添加一些动态光影效果 */
  .center-image .img-3d::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.1) 0%,
      transparent 50%,
      rgba(0, 0, 0, 0.05) 100%
    );
    pointer-events: none;
    border-radius: inherit;
  }

  /* 响应式设计 */
  @media (max-width: 768px) {
    .image-caption {
      bottom: -30px;
    }
    
    .image-caption p {
      font-size: 10px;
      padding: 4px 8px;
    }

    /* 在移动设备上减少3D效果以提升性能 */
    .image-3d {
      transition: all 0.3s ease;
    }
  }

  @media (max-width: 480px) {
    .image-caption {
      bottom: -25px;
    }
  }
</style>
